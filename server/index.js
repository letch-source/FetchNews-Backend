// backend/server/index.js  (CommonJS)
const path = require('path');
require('dotenv').config({ path: path.resolve(__dirname, '../.env') });

const fs = require('fs');
const express = require('express');
const cors = require('cors');

// OpenAI is ESM-only; use a lazy dynamic import that works in CJS
let openaiClientPromise;
function getOpenAI() {
  if (!openaiClientPromise) {
    openaiClientPromise = (async () => {
      const { default: OpenAI } = await import('openai');
      return new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
    })();
  }
  return openaiClientPromise;
}

const app = express();

/* -------------------- CORS (with preflight) -------------------- */
const ALLOWED_ORIGINS = new Set([
  'http://localhost:3000',
  'http://localhost:5173',
  'https://news-podcast-app-frontend.onrender.com',
]);

const corsOptionsDelegate = (req, callback) => {
  const origin = req.header('Origin');
  const isAllowed = origin && ALLOWED_ORIGINS.has(origin);
  callback(null, {
    origin: isAllowed,
    credentials: false,
    methods: ['GET', 'POST', 'OPTIONS'],
    allowedHeaders: ['Content-Type', 'Accept'],
    optionsSuccessStatus: 204,
  });
};

app.use(cors(corsOptionsDelegate));
// Preflight for ANY route
app.options(/.*/, cors(corsOptionsDelegate));
/* -------------------------------------------------------------- */

app.use(express.json());

// static media for generated audio
const MEDIA_DIR = path.join(__dirname, 'media');
if (!fs.existsSync(MEDIA_DIR)) fs.mkdirSync(MEDIA_DIR, { recursive: true });
app.use('/media', express.static(MEDIA_DIR));

// request logger
app.use((req, _res, next) => {
  console.log(`[${new Date().toISOString()}] ${req.method} ${req.url}`);
  next();
});

// safe JSON helper (prevents empty 200s)
function safeJson(res, payload, status = 200) {
  let body = payload;
  if (!body || (typeof body === 'object' && Object.keys(body).length === 0)) {
    status = status >= 400 ? status : 500;
    body = { error: 'Empty response generated by server' };
  }
  res.status(status).type('application/json').send(JSON.stringify(body));
}

// health
app.get('/api/health', (_req, res) => {
  safeJson(res, { ok: true, env: process.env.NODE_ENV || 'dev' });
});

// env guards
if (!process.env.OPENAI_API_KEY) { console.error('❌ Missing OPENAI_API_KEY'); }
if (!process.env.NEWSAPI_KEY) { console.warn('⚠️ Missing NEWSAPI_KEY — summaries may be generic.'); }

const TOPIC_CATEGORIES = new Set([
  'business','entertainment','general','health','science','sports','technology','world'
]);

async function fetchHeadlinesForTopic(topic) {
  if (!process.env.NEWSAPI_KEY) return [];
  const u = new URL('https://newsapi.org/v2/top-headlines');
  u.searchParams.set('pageSize', '12'); u.searchParams.set('language', 'en');
  const canonical = String(topic || '').toLowerCase();
  if (TOPIC_CATEGORIES.has(canonical)) { u.searchParams.set('country', 'us'); u.searchParams.set('category', canonical); }
  else { u.searchParams.set('q', canonical || 'news'); }
  const resp = await fetch(u.toString(), { headers: { 'X-Api-Key': process.env.NEWSAPI_KEY } });
  if (!resp.ok) { const t = await resp.text(); throw new Error(`NewsAPI ${resp.status}: ${t}`); }
  const json = await resp.json(); return Array.isArray(json.articles) ? json.articles : [];
}

function dedupeArticles(arr) {
  const seen = new Set(); const out = [];
  for (const a of arr) { const key = (a.url || a.title || '').toLowerCase(); if (!key || seen.has(key)) continue; seen.add(key); out.push(a); }
  return out;
}

function buildBatchPrompt(topics, articles) {
  const lines = [
    `You are a concise news editor. Create one coherent audio-ready summary that covers these topics: ${topics.join(', ')}.`,
    `Write ~180–260 words. Be factual, neutral, no list formatting. Merge overlapping stories.`,
    `Headlines:`
  ];
  const snippets = articles.slice(0, 14).map((a, i) => {
    const src = a.source?.name || '';
    const ctx = [a.description, a.content].filter(Boolean).join(' ').slice(0, 600);
    const pub = a.publishedAt || '';
    const url = a.url || '';
    return `${i + 1}) ${a.title || 'Untitled'} — ${src} — ${pub} — ${url}\n${ctx}`;
  });
  return [...lines, ...snippets].join('\n');
}

async function synthesizeTTS(text) {
  try {
    const openai = await getOpenAI();
    const speech = await openai.audio.speech.create({
      model: 'gpt-4o-mini-tts', voice: 'alloy', input: text, format: 'mp3',
    });
    const buf = Buffer.from(await speech.arrayBuffer());
    const fname = `tts-${Date.now()}.mp3`; const fpath = path.join(MEDIA_DIR, fname);
    fs.writeFileSync(fpath, buf);
    return `/media/${fname}`; // relative; route handlers will make absolute
  } catch (e) { console.error('TTS error:', e?.message || e); return null; }
}

async function buildCombinedSummary(topics, originForAbsolute) {
  let collected = [];
  for (const t of topics) {
    try {
      const arts = await fetchHeadlinesForTopic(t);
      collected = collected.concat(arts.map(a => ({ ...a, _topic: t })));
    } catch (e) { console.error(`News fetch error for "${t}":`, e?.message || e); }
  }
  const deduped = dedupeArticles(collected);
  deduped.sort((a, b) => (new Date(b.publishedAt || 0) - new Date(a.publishedAt || 0)));
  const capped = deduped.slice(0, 14);
  const prompt = buildBatchPrompt(topics, capped);

  let combinedText = 'No summary produced.';
  try {
    const openai = await getOpenAI();
    const summaryResp = await openai.responses.create({ model: 'gpt-4o-mini', input: prompt });
    combinedText = (summaryResp.output_text || '').trim() || combinedText;
  } catch (e) { console.error('OpenAI summary error:', e?.message || e); }

  const audioRel = await synthesizeTTS(combinedText);
  const toAbs = p => originForAbsolute ? new URL(p, originForAbsolute).toString() : p;
  const combined = { id: `combined-${Date.now()}`, title: `Top ${topics.join(', ')} right now`, summary: combinedText, audioUrl: audioRel ? toAbs(audioRel) : null };
  const items = capped.map((a, i) => ({
    id: `a-${i}`, title: a.title || 'Untitled',
    summary: [a.description, a.content].filter(Boolean).join(' ').slice(0, 220) || '',
    url: a.url || '', source: a.source?.name || '', topic: a._topic || '', audioUrl: null,
  }));
  return { combined, items };
}

// single-topic
app.post('/api/summarize', async (req, res, next) => {
  try {
    const topic = (req.body?.topic || 'general').toString();
    const origin = `${req.protocol}://${req.get('host')}`;
    const result = await buildCombinedSummary([topic], origin);
    safeJson(res, { combined: result.combined, items: result.items });
  } catch (err) { next(err); }
});

// multi-topic
app.post('/api/summarize/batch', async (req, res, next) => {
  try {
    const topics = Array.isArray(req.body?.topics) ? req.body.topics.map(String) : [];
    if (!topics.length) return safeJson(res, { error: 'topics[] required' }, 400);
    const origin = `${req.protocol}://${req.get('host')}`;
    const result = await buildCombinedSummary(topics, origin);
    safeJson(res, { combined: result.combined, items: result.items });
  } catch (err) { next(err); }
});

// legacy alias
app.post('/api/generate', (req, res) => res.redirect(307, '/api/summarize'));

// JSON 404 for any /api/* not handled
app.use('/api', (req, res) => {
  safeJson(res, { error: `Not found: ${req.method} ${req.originalUrl}` }, 404);
});

// global error handler
app.use((err, _req, res, _next) => {
  console.error('Unhandled error:\n', err?.stack || err);
  safeJson(res, { error: 'Internal server error' }, 500);
});

const PORT = process.env.PORT || 3001;
app.listen(PORT, () => {
  console.log(`✅ API listening on http://localhost:${PORT}`);
});